name: Build variant

on:
  workflow_call:
    inputs:
      CMAKE_PROJECT_DIR:
        type: string
        required: true
      CMAKE_CONFIG_PRESET:
        type: string
        required: true
      CMAKE_BUILD_PRESET:
        type: string
        required: true
      BINARY_DIR:
        type: string
        required: true
      BINARY_NAME:
        type: string
        required: true
      BINARY_NAME_VAR:
        type: string
        required: true
      BINARY_VERSION:
        type: string
        required: true
      BINARY_VERSION_VAR:
        type: string
        required: true
      
      VARIANT:
        type: string
        required: true
    outputs:
      ARTIFACT_NAME:
        value: ${{ jobs.build.outputs.ARTIFACT_NAME }}
      PRODUCT_NAME:
        value: ${{ jobs.build.outputs.PRODUCT_NAME }}
      PRODUCT_VERSION:
        value: ${{ jobs.build.outputs.PRODUCT_VERSION }}
      BINARY_NAME:
        value: ${{ jobs.build.outputs.BINARY_NAME }}

env:
  BUILD_TYPE: Release
  VCPG_COMMIT_ID: '01b29f6d8212bc845da64773b18665d682f5ab66'
  COMMON_LIB_SSE_NAME: CommonLibSSE
  COMMON_LIB_VR_NAME: CommonLibVR

jobs:
  build:
    runs-on: windows-latest
    outputs:
      ARTIFACT_NAME: ${{ steps.export.outputs.ARTIFACT_NAME }}
      BINARY_NAME: ${{ steps.export.outputs.BINARY_NAME }}
      PRODUCT_NAME: ${{ steps.export.outputs.PRODUCT_NAME }}
      PRODUCT_VERSION: ${{ steps.export.outputs.PRODUCT_VERSION }}

    steps:
    - uses: actions/checkout@v3
      with:
        submodules: recursive

    - name: Restore artifacts, or setup vcpkg (do not install any package)
      uses: lukka/run-vcpkg@v10
      id: runvcpkg
      with:
        vcpkgDirectory: '${{ runner.workspace }}/b/vcpkg'
        vcpkgGitCommitId: '${{ env.VCPG_COMMIT_ID }}'
        vcpkgJsonGlob: '${{inputs.CMAKE_PROJECT_DIR}}/vcpkg.json'

    # There is no easy way to loop through all submodules in GitHub Actions to call actions/cache on each submodule separately, so for now it will support only CommonLib.
    - name: Cache submodules
      id: clib-sha
      shell: pwsh
      run: |
        $CLibSSESHA = git submodule | Select-String -Pattern ${{ env.COMMON_LIB_SSE_NAME }} | %{[string]$_} | %{$_.Split(" ")[1]}
        $CLibVRSHA = git submodule | Select-String -Pattern ${{ env.COMMON_LIB_VR_NAME }} | %{[string]$_} | %{$_.Split(" ")[1]}
        $CLibSSEPath = "${{inputs.BINARY_DIR}}/${{inputs.CMAKE_PROJECT_DIR}}/${{env.COMMON_LIB_SSE_NAME}}"
        $CLibVRPath = "${{inputs.BINARY_DIR}}/${{inputs.CMAKE_PROJECT_DIR}}/${{env.COMMON_LIB_VR_NAME}}"

        If (![string]::IsNullOrEmpty($CLibSSESHA)) {
          echo "Caching ${{env.COMMON_LIB_SSE_NAME}} at $CLibSSEPath"
          New-Item $CLibSSEPath -ItemType Directory -Force | Out-Null
        }

        If (![string]::IsNullOrEmpty($CLibVRSHA)) {
          echo "Caching ${{env.COMMON_LIB_VR_NAME}} at $CLibVRPath"
          New-Item $CLibVRPath -ItemType Directory -Force | Out-Null
        }

        echo "::set-output name=SSE_SHA::$CLibSSESHA"
        echo "::set-output name=VR_SHA::$CLibVRSHA"
        echo "::set-output name=SSE_PATH::$CLibSSEPath"
        echo "::set-output name=VR_PATH::$CLibVRPath"

    - name: Cache CommonLibSSE
      uses: actions/cache@v3
      if: steps.clib-sha.outputs.SSE_SHA != ''
      with:
        path: ${{steps.clib-sha.outputs.SSE_PATH}}
        key: ${{runner.os}}-${{env.COMMON_LIB_SSE_NAME}}-${{inputs.VARIANT}}-${{steps.clib-sha.outputs.SSE_SHA}}

    - name: Cache CommonLibVR
      uses: actions/cache@v3
      if: steps.clib-sha.outputs.VR_SHA != ''
      with:
        path: ${{steps.clib-sha.outputs.VR_PATH}}
        key: ${{runner.os}}-${{env.COMMON_LIB_VR_NAME}}-${{inputs.VARIANT}}-${{steps.clib-sha.outputs.VR_SHA}}      

    - name: Configure CMake
      shell: pwsh
      run: cmake --preset ${{inputs.CMAKE_CONFIG_PRESET}}

    - name: Run CMake with build config
      if: inputs.CMAKE_BUILD_PRESET != ''
      shell: pwsh
      run: cmake --build --preset ${{inputs.CMAKE_BUILD_PRESET}}

    - name: Run CMake
      if: inputs.CMAKE_BUILD_PRESET == ''
      shell: pwsh
      run: cmake --build ${{inputs.BINARY_DIR}} --config ${{env.BUILD_TYPE}}

    - id: export
      shell: pwsh
      run: |
        $PRODUCT_NAME = If (![string]::IsNullOrEmpty("${{inputs.BINARY_NAME}}")) {"${{inputs.BINARY_NAME}}"} Else { cmake -L -N ${{inputs.BINARY_DIR}} | grep "${{inputs.BINARY_NAME_VAR}}" | %{$_ -replace "${{inputs.BINARY_NAME_VAR}}:STRING=",""} }
        $PRODUCT_VERSION = If (![string]::IsNullOrEmpty("${{inputs.BINARY_VERSION}}")) {"${{inputs.BINARY_VERSION}}"} Else { cmake -L -N ${{inputs.BINARY_DIR}} | grep "^${{inputs.BINARY_VERSION_VAR}}" | %{$_ -replace "${{inputs.BINARY_VERSION_VAR}}:STRING=",""} }
        $BINARY_NAME = "${PRODUCT_NAME}.dll"
        $BINARY_PATH = "${{inputs.BINARY_DIR}}/${{inputs.CMAKE_PROJECT_DIR}}/${{env.BUILD_TYPE}}/${BINARY_NAME}"
        $MARKETING_SUFFIX = "${{inputs.VARIANT}}".ToUpper()
        $ARTIFACT_NAME = "${PRODUCT_NAME} $MARKETING_SUFFIX"

        echo "::set-output name=PRODUCT_NAME::$PRODUCT_NAME"
        echo "::set-output name=PRODUCT_VERSION::$PRODUCT_VERSION"
        echo "::set-output name=ARTIFACT_NAME::$ARTIFACT_NAME"
        echo "::set-output name=BINARY_PATH::$BINARY_PATH"
        echo "::set-output name=BINARY_NAME::$BINARY_NAME"
        echo "Built $BINARY_NAME âœ…"
        echo "Location: $BINARY_PATH"

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with: 
        name: ${{ steps.export.outputs.ARTIFACT_NAME }}
        if-no-files-found: error
        path: ${{ steps.export.outputs.BINARY_PATH }}
      
